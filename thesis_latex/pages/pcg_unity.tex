% print no page number
\thispagestyle{empty}

\chapter{Procedural Content Generation with Unity}

Την υλοποίηση αυτής της εργασίας μπορούμε να την χωρίσουμε σε δύο ξεχωριστές υλοποιήσεις. Την υλοποίηση ενός \textit{Procedural Content Generation} συστήματος όπως αυτά που περιγράψαμε στο προηγούμενο κεφάλαιο, και σε ένα \textit{Machine Learning Content Generation} σύστημα. Σε αυτό το κεφάλαιο αναλύουμε την τεχνική υλοποίηση του PCG.
\par
Μέχρι τώρα έχουμε αναλύσει την θεωρία πίσω από το αντικείμενο του PCG, καινούργιες προκλήσεις και προβλήματα προκύπτουν όταν προσπαθούμε να περάσουμε από την θεωρία στην πράξη, κάτι που συμβαίνει σε όλους τους επιστημονικούς τομείς και το PCG δεν αποτελεί  εξαίρεση.
\par
Από το στάδιο της αρχικής ιδέας μέχρι την έναρξη της υλοποίησης μπορούμε να διακρίνουμε ένα ενδιάμεσο στάδιο, του σχεδιασμού και της έρευνας σχετικά με τις τεχνολογίες, τις δομές δεδομένων και τους αλγορίθμους που θα κληθούμε να υλοποιήσουμε. Αυτή η προσέγγιση ισχύει για όλες τις υλοποιήσεις της επιστήμης της πληροφορικής και ειδικότερα του game development όπου έχουμε πολλά υποσυστήματα που θα πρέπει να λειτουργήσουν παράλληλα και να συνεργαστούν με το σύστημα του PCG. Οπότε η σωστή οργάνωση και σχεδιασμός της αρχιτεκτονικής του νωρίς είναι πολύ κρίσιμο κομμάτι.
\par
Κατά την υλοποίηση και ιδιαίτερα κατά το στάδιο της αξιολόγησης όπως είδαμε μπορεί να προκύψουν προβλήματα όπως μη αποδεκτά αποτελέσματα, γεγονός που μπορεί να οδηγήσει στον ανασχεδιασμό και την επιλογή διαφορετικών αλγορίθμων ή παραμέτρων. Αυτή η διαδικασία μπορεί να επαναληφθεί πολλές φορές καθώς, όπως ειπώθηκε και προηγουμένως, τα \textit{καλά} συστήματα PCG βγαίνουν μέσα από δοκιμές και λάθη (\textit{trial and error}).
\par
Παρόλαυτα, η υλοποίηση ενός τέτοιου συστήματος μπορεί να θεωρηθεί, και είναι και η προσωπική εμπειρία της συγγραφέας, ως μια πολύ δημιουργική εργασία, ειδικά σε σύγκριση με την διαδικασία ανάπτυξης άλλων ειδών λογισμικού. Πρόβληματα που απαιτούν σκέψη \textit{outside of the box} και δημιουργηκότητα, σε συνδυασμό με πολύ καλή γνώση της θεωρίας και της τεχνολογίας είναι ένα από τα χαρακτηριστικά που κάνουν αυτή την ανάπτυξη λογισμικού τόσο ενδιαφέρουσα και ιδιαίτερη.
Είδαμε μερικούς από τους αλγόριθμους που μπορούν να χρησιμοποιηθούν για την δημιουργία περιεχομένου. Υπάρχουν πολλοί περισσότεροι, ο καθένας με τις παραλλαγές του. Συνεπώς είναι πολύ εύκολο να δημιουργήσουμε περιεχόμενο, το δύσκολο κομμάτι του PCG είναι η δημιουργία \textbf{καλού} περιεχομένου. Σε αυτή την ενότητα θα αναλύσουμε πως γίνετε την αξιολόγηση PCG συστημάτων με τη χρήση άλλων συστημάτων, των evaluators.

\section{Game Engines}
Οι Μηχανές Δημιουργίας Ηλεκτρονικών Παιχνιδιών (\textit{Game Engines}) είναι περιβάλλοντα υλοποίησης παιχνιδιών, όπως περιγράφει και το όνομα τους. Είναι πολύπλοκα υπολογιστικά συστήματα που χρησιμοποιούνται από εταιρείες και ομάδες ανθρώπων σε όλο τον κόσμο για την υλοποίηση όλων των ειδών τα ηλεκτρονικά παιχνίδια. Συνήθως περιλαμβάνουν συστήματα για να βοηθήσουν τους προγραμματιστές και σχεδιαστές στην υλοποίηση, όπως το σύστημα προσομοίωσης φυσικών καταστάσεων και νόμων (ταχύτητα, επιτάχυσνη, βαρύτητα).
\par
Άλλα τέτοια συστήματα που έχουν τα περισσότερα Game Engines είναι συστήματα για την καταγραφή και επεξεργασία των εισόδων που δίνει ο χρήστης (πάτημα κουμπιού, κίνηση ποντικιού κ.ά), συστήματα για την εμφάνιση γραφικών (\textit{textures}, \textit{sprites}), συστήματα για την κίνηση αντικειμένων με γραφικά (\textit{animations}) και πολλά άλλα.
\par
Υπάρχουν Game Engines που εξειδικεύονται στην δημιουργία ενός συγκεκριμένου είδους παιχνιδιού, όπως για παράδειγμα το \textit{Hero Engine} εξειδικεύεται στην δημιουργία παιχνιδιών που παίξονται μέσω Internet (\textit{Online video games}). Αυτό σημαίνει ότι το Hero Engine έχει πολύ καλά ανεπτυγμένα συστήματα για την επικοινωνία \textit{client-server} εφαρμογών σε πραγματικό χρόνο καθώς και την διαχείριση δεδομένων που αποθηκεύονται κεντρικά σε κάποιο \textit{server}.
\par
Επίσης υπάρχουν και τα Game Engines που δεν φαίνετε να έχουν κάποια εξειδίκευση σε κανένα είδος, αλλά υποστηρίζουν ότι είδους game και αν θέλουμε να ανατπύξουμε. Αυτά τα Game Engine έχουν γνωρίσει μεγάλη δημοτικότητα τα τελευταία χρόνια, σε συνδυασμό με το γεγονός ότι είναι διαθέσιμα για όλους, με αποτέλεσμα να διευρυνθεί η χρήση τους με μεγάλη επιτυχία από ομάδες όλων των μεγεθών (μικρά independent studio και developers μέχρι μεγάλες εταιρείες). Τέτοια Game Engines είναι το Unity Engine, το Unreal Engine, το Godot Engine (το οποίο είναι OpenSource) κ.ά.
\par
Η εκμάθηση ενός τέτοιου προγράμματος παίρνει χρόνο και μελέτη, καθώς το κάθε Game Engine έχει δικές του υλοποιήσεις για το κάθε σύστημα, διαφορετικό περιβάλλον αλληλεπίδρασης με τον χρήστη (\textit{editor}) καθώς και διαφορετική γλώσσα προγραμματισμού που πρέπει να χρησιμοποιήσει ο προγραμματιστής. Υπάρχουν πολλά κριτήρια για την επιλογή ποιού Game Engine θα χρησιμοποιηθεί για την υλοποίηση ενός παιχνιδιού ή συστήματος, όπως στη δική μας περίπτωση. Τα πιο σημαντικά είναι:
\begin{itemize}
  \item Οι γνώσεις της ομάδας (Game Engine, γλώσσα προγραμματισμού)
  \item Οι
\end{itemize}

\begin{description}
\item[$\bullet$ Οι γνώσεις της ομάδας] Εάν έχουν προηγούμενη εμπειρία με κάποιο από τα διαθέσιμα Game Engines και με τις υποστηριζόμενες γλώσσες προγραμματισμού
\item[$\bullet$ Οι δυνατότητες του Game Engine] Εάν ο στόχος είναι η υλοποίησης μιας εφαρμογής για κινητές συσκευές, πρέπει να επιλεχθεί ένα Game Engine που να υποστηρίζει αυτή την πλατφόρμα.
\item[$\bullet$ Το κόστος του Game Engine] Πολλά Game Engines δεν παρέχονται ελεύθερα ή για να έχουμε πρόσβαση σε κάποιες λειτουργίες τους χρειάζετε η καταβολή κάποιου ποσού.
\end{description}

\par
Σε αυτή την υλοποίηση επιλέχθηκε το \textbf{Unity Game Engine} καθώς η συγγραφέας το γνωρίζει όπως και την γλώσσα προγραμματισμού \textbf{C\#} που χρησιμοποιήθηκε. Επιπλέον παρέχετε δωρεάν υπό προυποθέσεις.


\section{Unity Game Engine}

\subsection{Τεχνικά χαρακτηριστικά}
Για την υλοποίηση χρησιμοποιήθηκε \textbf{Unity 2019.2.8f1} με \textbf{C\#} και \textbf{API compatibility Level .Net Standard 2.0}. 

\subsection{Βιβλιοθήκες Unity}
Χρησιμοποιήθηκαν κάποιες έτοιμες βιβλιοθήκες και συστήματα που παρέχει το Unity Game Engine και η γλώσσα \textbf{C\#}. Συγκεκριμένα έγινε χρήση των:

\begin{description}
\item[$\bullet$ Tilemap System] Είναι ένα από τις πιο πρόσφατες προσθήκες στα διαθέσιμα συστήματα του Unity. Παρέχει μεθόδους για την τοποθέτηση, προβολή και επεξεργασία δισδιάστατων γραφικών (\textit{sprites}) ως κομμάτια ενός ορισμένου δισδιάστατου χώρου.
\item[$\bullet$ Canvas System] Ελέγχει την τοποθέτηση και λειτουργικότητα των \textit{controls} με τα οποία ο χρήστης αλληλεπιδρά με την εφαρμογή.
\end{description}


\section{Σχεδιασμός συστήματος PCG}
Πριν από το στάδιο του σχεδιασμού είχαμε κάνει μια έρευνα πάνω στο αντικείμενο του \textit{Procedural Content Generation} και του  \textit{Machine Learning Content Generation} και ειδικά στις εφαρμογές που σχετίζονταν με το \textit{Dungeon Generation} και το \textit{Level Generation}. Είχαμε διαπιστώσει οτι παρόλο που η βιβλιογραφία πάνω στους αλγόριθμους που μπορούν να εφαρμοστούν είναι ιδιαίτερα εκτενής και αναλυτική, τα διαθέσιμα \textit{dataset} που ενδείκνονται για αυτό το σκοπό είναι ελάχιστα.
\par
Αποφασίσαμε να επεκτείνουμε την υλοποίηση ώστε να περιλαμβάνει και ένα σύστημα \textit{Procedural Content Generation} για \textit{2D Levels} ώστε να είμαστε σε θέση να δημιουργήσουμε εμείς το \textit{dataset} που θα χρησιμοποιήσουμε για την εκπαίδευση των \textit{Machine Learning} μοντέλων. Με αυτό τον τρόπο μπορούμε να ελέγξουμε απόλυτα το μέγεθος, το είδος αναπαράστασης και τα δεδομένα που περιέχει το \textit{dataset} μας, ώστε να πετύχουμε το καλύτερο δυνατό αποτέλεσμα με την εκπαίδευση.
\par
Θεωρούμε ότι αυτή η προσέγγιση καλύπτει πιο σφαιρικά το πρόβλημα της δημιουργίας περιεχόμενου καθώς το προσεγγίζει όπως θα το προσέγγιζε και μια εταιρεία που ήθελε να κατασκευάσει ένα τέτοιο σύστημα. Για να το εκπαιδεύσει να παράγει επίπεδα που θα μπορούσε να χρησιμοποιήσει σε κάποιο παιχνίδι θα μάζευε το απαραίτητο dataset, είτε θα έβαζε τους σχεδιαστές να φτιάξουν ένα, θα χρησιμοποιούσε παλιότερα assets ή θα δημιουργούσε ένα PCG σύστημα για να το παράγει.
\par
Ταυτόχρονα αυτό μας έδωσε την δυνατότητα να ερευνήσουμε σε ακόμα μεγαλύερο βάθος την θεωρία και τους αλγορίθμους του \textit{PCG}. Η υλοποίηση αυτή αποτελεί από μία οπτική τον \textit{dataset generator} του \textit{Machine Learning} μοντέλου. Παράλληλα αναπτύξαμε και μηχανισμούς αξιολόγησης και προβολής των αποτελεσμάτων και των δύο συστημάτων (PCG, MLPG).


\subsection{Περιγραφή Επιπέδου}
To επίπεδο που προσπαθούμε να δημιουργήσουμε όπως αναφέρθηκε είναι δισδιάστατο και αποτελείται από τετράγωνα (\textit{tiles}). Το μέγεθος του μετριέται σε tiles ανά πλευρά του επιπέδου. Στην υλοποίηση του συστήματος PCG ο αριθμός των tiles ανά πλευρά είναι παράμετρος που μπορεί να αλλάξει αλλά για την εκπαίδευση του MLPG χρησιμοποιήθηκε dataset με σταθερό και ίδιο μέγεθος επιπέδου για όλα τα δείγματα.
\par
Κάθε tile μπορεί να πάρει μία από τις παρακάτω τιμές:
\begin{itemize}
\item Τοίχος (\textit{Wall})
\item Διάδρομος (\textit{Corridor})
\item Δωμάτιο(\textit{Room})
\end{itemize}

Με αυτά τα τρία είδη tiles θέλουμε να καταστευάσουμε επίπεδα που περιέχουν έναν αριθμό από δωμάτια, τα οποία περιτρυγιρίζονται από τοίχους και συνδέονται μεταξύ τους με διαδρόμους. Η τοποθέτηση αυτών των tiles σε σωστές θέσεις ώστε να σχηματίζονται επίπεδα που ταιριάζουν στην παραπάνω περιγραφή είναι ο γενικός στόχος των συστημάτων PCG και MLPG που προσπαθούμε να υλοποιήσουμε.

\section{Υλοποίηση συστήματος PCG}

\subsection{Υποσυστήματα}
Το σύστημα PCG αποτελείται από πολλά υποσυστήματα, τα οποία θα αναλύσουμε σε αυτό το κομμάτι. Το κάθε υποσύστημα έχει σχεδιαστεί με την λογική ότι αποτελεί ένα μεμονομένο κομμάτι λογισμικού, παίρνει συγκεκριμένες εισόδους από άλλα υποσυστήματα ή τον χρήστη και παράγει εξόδους αντίστοιχα για τα άλλα υποσυστήματα και τον χρήστη. Ονομαστικά αυτά τα υποσυστήματα είναι:

\begin{description}
\item[$\bullet$ Configuration System] Σύστημα αποθήκευσης και ανάγνωσης ρυθμίσεων.
\item[$\bullet$ Generation System] Περιέχει κλάσεις και μεθόδους για την δημιουργία ενός ή παραπάνω επιπέδων.
\item[$\bullet$ Data System] Περιέχει τις δομές δεδομένων, τις abstract κλάσεις και τα enumerations που αναπαριστούν όλες τις πληροφορίες που διαχειρίζεται το σύστημα PCG.
\item[$\bullet$ ΙΟ System] Παρέχει μεθόδους για την αποθήκευση των δημιουργημένων επιπέδων σε διάφορες μορφές όπως σε μορφή γράφου ή σε αρχείο. Επίσης παρέχει μεθόδους για την ανάγνωση επιπέδων και μετατροπή τους σε κάποια άλλη μορφή αναπαράστασης.
\item[$\bullet$ UI System] Περιέχει την λειτουργικότητα του συστήματος αλληλεπίδρασης με τον χρήστη.
\item[$\bullet$ Evaluation System] Είναι υπεύθυνο για την αξιολόγηση ενός επιπέδου με βάση συγκεκριμένους κανόνες που ορίζονται κατά την υλοποίηση.
\end{description}

\subsection{Αλγόριθμος PCG}
Ως βασικός αλγόριθμος για το σύστημα δημιουργίας επιπέδων 2D χρησιμοποιήθηκε ένας αλγόριθμος \textit{Space Partitioning}. O αλγόριθμος παίρνει τις διαστάσεις του επιπέδου, οι οποίες όπως είπαμε είναι σταθερές για κάθε επίπεδο, και χωρίζει το δωμάτιο οριζόντια σε τυχαίο αριθμό από παράλληλα επίπεδα. Στη συνέχεια για κάθε παράλληλο επίπεδο το χωρίζει κάθετα σε τυχαία δωμάτια. Ο αριθμός των παράλληλων και των κάθετων διαχωρισμός επιλέγετε τυχαία με βάση το μέγεθος του επιπέδου.
\par
Με αυτό τον αλγόριθμο μπορούμε να έχουμε επίπεδα που ακολουθούν ένα συγκεκριμένο μοτίβο αλλά διαφέρουν στον αριθμό και το μέγεθος των δωματίων που εχει το καθένα όπως θα δούμε και στα παραδείγματα των δημιουργημένων επιπέδων.
\par
Όλη η διαδικασία δημιουργίας του επιπέδου γίνετε άμεσα χωρίς να υπάρχει κάποια εμφανή καθυστέριση στον χρήστη. Για την δημιυργία του \textit{dataset} υλοποιήθηκε η επιλογή ο αλγόριθμος PCG να τρέξει έναν αριθμό επαναλήψεων καθορισμένο από τον χρήστη ώστε να παράγει μαζικά πολλά επίπεδα.

\subsection{Βήματα αλγορίθμου PCG}
Τα βήματα του αλγορίθμου PCG αναλυτικά είναι:

\begin{enumerate}
	\item Γέμισμα όλου του επιπέδου με ένα είδος tile. Αυτό το tile είναι του είδους \textbf{Room}.
	\item Ανάθεση των tiles που είναι στις άκρες του επιπέδου με tiles είδους \textbf{Wall}
	\item Ανάθεση των tiles που είναι στις άκρες του επιπέδου, δίπλα στα tiles με είδος \textbf{Wall} με tiles είδους \textbf{Corridor}.
	\item Υπολογισμός δωματίων.
	\item Τοποθέτηση δωματίων στο επίπεδο. Σε αυτό το βήμα ο τα tiles που δεν είναι είδους \textbf{Room} γίνονται tiles είδους \textbf{Corridor}.
	\item Τοποθέτηση tiles είδους \textbf{Wall} γύρω από τα δωμάτια.
	\item Αποθήκευση παραγμένου επιπέδου σε αρχείο.
	\item Αξιολόγηση του επιπέδου. Προεραιτικό βήμα.
\end{enumerate}


\subsection{Κανόνες μετατροπής}
Για τα βήματα \textbf{2}, \textbf{5} και \textit{6} όπου υλοποιείται η μετατροπή \textit{tiles} από ένα είδος σε ένα άλλο χρησιμοποιήθηκαν κανόνες μετατροπής. Οι κανόνες αυτοί παίρνουν ως είσοδο ένα tile και ανάλογα με το είδος του κανόνα το μετατρέπουν σε κάποιο άλλο είδος tile ή το αφήνουν ίδιο.
\par
Υλοποιήθηκαν δύο κατηγορίες κανόνων. H πρώτη κατηγορία περιέχει κανόνες όπως αυτοί που αναλύσαμε στο κομμάτι σχετικά με τα \textbf{Cellular Automata} που χρησιμοποιούν την \textit{γειτονιά} του tile για την μετατροπή. Η δεύτερη κατηγορία χρησιμοποιεί όρια μιας περιοχής για να εφαρμόσει μετατροπές στο είδος των tiles αυτής της περιοχής. 
\par
Για την πρώτη κατηγορία, υλοποιήθηκε η λογική της \textit{γειτονιάς} ενός \textit{tile} (cell) και ορίστηκε σε μια γενική μορφή (\textit{abstraction}) η έννοια του κανόνα. Ο κανόνας ως \textit{abstract class} μπορεί να εφαρμοστεί σε ένα \textit{tile} και ανάλογα με την υλοποίηση που έχει γίνει και την \textit{γειτονιά} του tile να γίνει μετατροπή του tile από ένα είδος σε ένα άλλο. Για τις ανάγκες αυτής της υλοποίησης χρησιμοποιήθηκε η \textbf{Moore Neighborhood} και η \textbf{Von Neumann Neighborhood} ανάλογα με τις ανάγκες κάθε κανόνα. Η γειτονιά μας σε κάθε περίπτωση είναι απόστασης \textit{X = 1}.
\par
Η ίδια γενική μορφή (\textit{abstraction}) ακολουθήθηκε και για την υλοποίηση των κανόνων της δεύτερης κατηγορίας. Τα όρια μπορεί να είναι τα όρια του επιπέδου, σε αυτή την περίπτωση ο κανόνας που θα εφαρμοστεί να μετατρέψει μόνο τα tiles περιμετρικά του επιπέδου σε ότι είδος δώσουμε ως παράμετρο όταν εφαρμόσουμε τον κανόνα.
\par
Οι κανόνες που υλοποιήθηκαν για αυτή την εφαρμογή είναι οι εξής:

\begin{description}
\item[$\bullet$ WALL FROM BOUNDS] Κανόνας μετρατροπής σε \textbf{Wall} των tiles που είναι στα όρια μιας περιοχής. Χρησιμοποιείται για να γεμίσει περιμετρικά το επίπεδο με \textbf{Wall} tiles.
\item[$\bullet$ FLOOR FROM BOUNDS] Κανόνας μετρατροπής σε \textbf{Corridor} των tiles που είναι στα όρια μιας περιοχής. Χρησιμοποιείται για να γεμίσει με διαδρόμους τους χώρους γύρω από τα δωμάτια και τους περιμετρικούς τοίχους.
\item[$\bullet$ WALL FOR ROOM] Κανόνας μετρατροπής σε \textbf{Wall} των tiles με βάση την \textbf{Von Neumann Neighborhood}. Αυτός ο κανόνας ελέγχει όλα τα tiles της γειτονιάς και αν έστς και ένα είναι είδους\textbf{Corridor} τότε μετατρέπει το tile σε \textbf{Wall}. Χρησιμοποιείται για να κλείσει τα δωμάτια με τοίχους.
\item[$\bullet$ WALL FROM ADJACENTS] Κανόνας μετρατροπής σε \textbf{Wall} των tiles με βάση την \textbf{Moore Neighborhood}. Εάν τα μισά και παραπάνω tiles της γειτονιάς είναι είδους \textbf{Wall} τότε και το tile θα μετατραπεί σε \textbf{Wall}.
\item[$\bullet$ ROOM FROM ADJACENTS] Κανόνας μετρατροπής σε \textbf{Room} των tiles με βάση την \textbf{Von Neumann Neighborhood}. Εάν τα μισά και παραπάνω tiles της γειτονιάς είναι είδους \textbf{Room} τότε και το tile θα μετατραπεί σε \textbf{Room}.
\end{description}

\par
Οι δύο τελευταίοι κανόνες αν και υλοποιήθηκαν για τις αρχικές ανάγκες της εφαρμογής τελικά αντικαταστήθηκαν από τους άλλους κανόνες και δεν χρησιμοποιούνται στην τελική της έκδοση. O κώδικας παρέμεινε στην εφαρμογή και περιγράφετε και εδώ για θεωρητικούς λόγους.






















