% print no page number
\thispagestyle{empty}

\chapter{Procedural Content Generation with Unity}

Την υλοποίηση αυτής της εργασίας μπορούμε να την χωρίσουμε σε δύο ξεχωριστά εννοιολογικά κομμάτια. Το πρώτο κομμάτι αφορά την υλοποίηση ενός \textit{Procedural Content Generation} συστήματος όπως αυτά που περιγράψαμε στο προηγούμενο κεφάλαιο, και σε ένα \textit{Machine Learning Content Generation} σύστημα. Σε αυτό το κεφάλαιο αναλύουμε την τεχνική υλοποίηση του PCG.
\par
Από το στάδιο της αρχικής ιδέας μέχρι την έναρξη της υλοποίησης μπορούμε να διακρίνουμε ένα ενδιάμεσο στάδιο, του σχεδιασμού και της έρευνας σχετικά με τις τεχνολογίες, τις δομές δεδομένων και τους αλγορίθμους που θα κληθούμε να υλοποιήσουμε. Αυτή η ιεραρχία από την ιδέα έως την υλοποίηση, ισχύει για όλες τις εφαρμογές της επιστήμης της πληροφορικής και ειδικότερα του game development \textit{gamedevprocess}, όπου έχουμε πολλά υποσυστήματα που θα πρέπει να λειτουργήσουν παράλληλα και να συνεργαστούν με το σύστημα του PCG. Η σωστή οργάνωση και σχεδίαση της αρχιτεκτονικής του PCG είναι ένα πολύ κρίσιμο κομμάτι.
\par
Κατά την υλοποίηση και ιδιαίτερα κατά το στάδιο της αξιολόγησης όπως είδαμε μπορεί να προκύψουν προβλήματα όπως μη αποδεκτά αποτελέσματα, γεγονός που μπορεί να οδηγήσει στον ανασχεδιασμό και την επιλογή διαφορετικών αλγορίθμων ή παραμέτρων. Αυτή η διαδικασία μπορεί να επαναληφθεί πολλές φορές καθώς, όπως αναλύθηκε, τα \textit{καλά} συστήματα PCG βγαίνουν μέσα από δοκιμές και λάθη (\textit{trial and error}).
\par
Η υλοποίηση ενός τέτοιου συστήματος μπορεί να θεωρηθεί, και είναι και η προσωπική εμπειρία της συγγραφέας, ως μια πολύ δημιουργική εργασία, ειδικά σε σύγκριση με την διαδικασία ανάπτυξης άλλων ειδών λογισμικού. Προβλήματα που απαιτούν σκέψη \textit{outside of the box} και δημιουργικότητα, σε συνδυασμό με πολύ καλή γνώση της θεωρίας και της τεχνολογίας είναι ένα από τα χαρακτηριστικά που κάνουν αυτόν τον τομέα της πληροφορικής, τόσο ενδιαφέρον και ιδιαίτερο.

\section{Game Engines}
Οι Μηχανές Δημιουργίας Ηλεκτρονικών Παιχνιδιών (\textit{Game Engines}) είναι σχεδιαστικά περιβάλλοντα υλοποίησης παιχνιδιών, όπως περιγράφει και το όνομα τους. Είναι πολύπλοκα υπολογιστικά συστήματα που χρησιμοποιούνται από εταιρείες και ομάδες ανθρώπων σε ολόκληρο τον κόσμο για την υλοποίηση ηλεκτρονικών παιχνιδιών. Συνήθως περιλαμβάνουν συστήματα που βοηθάνε τους προγραμματιστές και σχεδιαστές, όπως το σύστημα προσομοίωσης νόμων της φυσικής όπως κίνηση αντικειμένων, βαρύτητα κ.ά. (Physics Engine). \cite{gameengine}
\par
Συστήματα που έχουν τα περισσότερα Game Engines είναι το σύστημα για την καταγραφή και επεξεργασία των εισόδων του χρήστης όπως το πάτημα ενός κουμπιού, η κίνηση του ποντικιού κ.ά (Input Engine), σύστημα για την εμφάνιση γραφικών (\textit{textures}, \textit{sprites}) (Graphics Engine), σύστημα για την κίνηση αντικειμένων με γραφικά (\textit{animations})(Animation Engine) και πολλά ακόμη.
\par
Υπάρχουν Game Engines που εξειδικεύονται στην δημιουργία ενός συγκεκριμένου είδους παιχνιδιού, όπως για παράδειγμα το \textit{Hero Engine} εξειδικεύεται στην δημιουργία παιχνιδιών που παίζονται μέσω Internet (\textit{Online video games}). Αυτό σημαίνει ότι το Hero Engine έχει πολύ καλά ανεπτυγμένα συστήματα για την επικοινωνία \textit{client-server} εφαρμογών σε πραγματικό χρόνο καθώς και την διαχείριση δεδομένων που αποθηκεύονται κεντρικά σε κάποιο \textit{servers}.
\par
Επίσης υπάρχουν και τα Game Engines που δεν φαίνεται να έχουν κάποια εξειδίκευση σε κανένα είδος, αλλά υποστηρίζουν το κάθε είδους game που θέλουμε να αναπτύξουμε. Αυτά τα Game Engine έχουν γνωρίσει μεγάλη δημοτικότητα τα τελευταία χρόνια, σε συνδυασμό με το γεγονός ότι είναι ελεύθερα διαθέσιμα, με αποτέλεσμα να διευρυνθεί η χρήση τους με μεγάλη επιτυχία από ομάδες όλων των μεγεθών (μικρά independent studio και developers μέχρι μεγάλες εταιρείες). Τέτοια Game Engines είναι το Unity Engine \cite{unity}, το Unreal Engine \cite{unreal}, το Godot Engine (το οποίο είναι OpenSource) \cite{godot} κ.ά.
\par
Η εκμάθηση ενός τέτοιου προγράμματος απαιτεί χρόνο και μελέτη, καθώς το κάθε Game Engine έχει δικές του υλοποιήσεις για το κάθε σύστημα, διαφορετικό περιβάλλον αλληλεπίδρασης με τον χρήστη (\textit{editor}) καθώς και διαφορετική γλώσσα προγραμματισμού που πρέπει να χρησιμοποιήσει ο προγραμματιστής. Υπάρχουν πολλά κριτήρια για την επιλογή ποιο Game Engine θα χρησιμοποιηθεί για την υλοποίηση ενός παιχνιδιού ή συστήματος, όπως στη δική μας περίπτωση. Τα πιο σημαντικά είναι:
\begin{itemize}
  \item Οι γνώσεις της ομάδας (Game Engine, γλώσσα προγραμματισμού)
  \item Οι δυνατότητες που προσφέρει το Game Engine για τον συγκεκριμένο τύπο παιχνιδιού
  \item Το κόστος ανάπτυξης στο συγκεκριμένο Game Engine
\end{itemize}

\begin{description}
\item[$\bullet$ Οι γνώσεις της ομάδας] Εάν έχουν προηγούμενη εμπειρία με κάποιο από τα διαθέσιμα Game Engines και με τις υποστηριζόμενες γλώσσες προγραμματισμού
\item[$\bullet$ Οι δυνατότητες του Game Engine] Εάν ο στόχος είναι η υλοποίησης μιας εφαρμογής για κινητές συσκευές, πρέπει να επιλεχθεί ένα Game Engine που να υποστηρίζει αυτή την πλατφόρμα.
\item[$\bullet$ Το κόστος του Game Engine] Πολλά Game Engines δεν παρέχονται ελεύθερα ή για να έχουμε πρόσβαση σε κάποιες λειτουργίες τους χρειάζεται η καταβολή κάποιου ποσού.
\end{description}

\par
Σε αυτή την υλοποίηση επιλέχθηκε το \textbf{Unity Game Engine} καθώς η συγγραφέας το γνωρίζει όπως και την γλώσσα προγραμματισμού \textbf{C\#} που χρησιμοποιήθηκε. Επιπλέον παρέχετε δωρεάν υπό προϋποθέσεις.


\section{Unity Game Engine}

\subsection{Τεχνικά χαρακτηριστικά}
Για την υλοποίηση χρησιμοποιήθηκε \textbf{Unity 2019.2.8f1} με \textbf{C\#} και \textbf{API compatibility Level .Net Standard 2.0}. 

\subsection{Βιβλιοθήκες Unity}
Χρησιμοποιήθηκαν κάποιες έτοιμες βιβλιοθήκες και συστήματα που παρέχει το Unity Game Engine και η γλώσσα \textbf{C\#}. Συγκεκριμένα έγινε χρήση των:

\begin{description}
\item[$\bullet$ Tilemap System] Είναι ένα από τις πιο πρόσφατες προσθήκες στα διαθέσιμα συστήματα του Unity. Παρέχει μεθόδους για την τοποθέτηση, προβολή και επεξεργασία δισδιάστατων γραφικών (\textit{sprites}) ως κομμάτια ενός ορισμένου δισδιάστατου χώρου. \cite{unitytilemap}
\item[$\bullet$ Canvas System] Ελέγχει την τοποθέτηση και λειτουργικότητα των \textit{controls} με τα οποία ο χρήστης αλληλεπιδρά με την εφαρμογή. \cite{unitycanvas}
\end{description}


\section{Σχεδιασμός συστήματος PCG}
Πριν από το στάδιο του σχεδιασμού ολοκληρώθηκε μια έρευνα πάνω στο αντικείμενο του \textit{Procedural Content Generation} \cite{answersetforpcg} \cite{constrainedsearchpcg} \cite{surrogate}, \cite{roguedream} και του  \textit{Machine Learning Content Generation \cite{mlpcg}} και ειδικά στις εφαρμογές που σχετίζονταν με το \textit{Dungeon Generation} και το \textit{Level Generation} \cite{cellular}, \cite{missions}, \cite{platform}. Διαπιστώθηκε ότι παρόλο που η βιβλιογραφία πάνω στους αλγόριθμους που μπορούν να εφαρμοστούν είναι ιδιαίτερα εκτενής και αναλυτική, τα διαθέσιμα \textit{dataset} που ενδείκνυνται για αυτό το σκοπό είναι ελάχιστα.
\par
Αποφασίσαμε να επεκτείνουμε την υλοποίηση ώστε να περιλαμβάνει και ένα σύστημα \textit{Procedural Content Generation} για \textit{2D Levels} ώστε να είμαστε σε θέση να δημιουργήσουμε εμείς το \textit{dataset} που θα χρησιμοποιήσουμε για την εκπαίδευση των \textit{Machine Learning} μοντέλων. Με αυτό τον τρόπο μπορούμε να ελέγξουμε απόλυτα το μέγεθος, το είδος αναπαράστασης και τα δεδομένα που περιέχει το \textit{dataset} μας, ώστε να πετύχουμε το καλύτερο δυνατό αποτέλεσμα με την εκπαίδευση.
\par
Θεωρούμε ότι αυτή η προσέγγιση καλύπτει πιο σφαιρικά το πρόβλημα της δημιουργίας περιεχόμενου καθώς το προσεγγίζει όπως θα το προσέγγιζε και μια εταιρεία που ήθελε να κατασκευάσει ένα τέτοιο σύστημα. Για να εκπαιδεύσει τα μοντέλα Μηχανικής Μάθησης να παράγουν επίπεδα που θα μπορούσε να χρησιμοποιήσει σε κάποιο παιχνίδι, θα δημιουργούσε το απαραίτητο dataset. Η δημιουργία του dataset θα γινόταν είτε από τους σχεδιαστές, θα συγκεντρώνοντας παλιότερα assets ή μέσω ενός PCG συστήματος.
\par
Ταυτόχρονα αυτό μας έδωσε την δυνατότητα να ερευνήσουμε σε ακόμα μεγαλύτερο βάθος την θεωρία και τους αλγορίθμους του PCG. Η υλοποίηση αυτή αποτελεί από μία οπτική τον \textit{dataset generator} του \textit{Machine Learning} μοντέλου. Παράλληλα αναπτύξαμε και μηχανισμούς αξιολόγησης και προβολής των αποτελεσμάτων και των δύο συστημάτων (PCG, MLPG).


\subsection{Περιγραφή Επιπέδου}
Το επίπεδο που προσπαθούμε να δημιουργήσουμε όπως αναφέρθηκε είναι δισδιάστατο και αποτελείται από τετράγωνα (\textit{tiles}). Το μέγεθος του μετριέται σε tiles ανά πλευρά του επιπέδου. Στην υλοποίηση του συστήματος PCG ο αριθμός των tiles ανά πλευρά είναι παράμετρος που μπορεί να αλλάξει αλλά για την εκπαίδευση του MLPG χρησιμοποιήθηκε dataset με σταθερό μέγεθος επιπέδου για όλα τα δείγματα.
\par
Κάθε tile μπορεί να πάρει μία από τις παρακάτω τιμές:
\begin{itemize}
\item Τοίχος (\textit{Wall})
\item Διάδρομος (\textit{Corridor})
\item Δωμάτιο(\textit{Room})
\end{itemize}

Με αυτά τα τρία είδη tiles θέλουμε να κατασκευάσουμε επίπεδα που περιέχουν έναν αριθμό από δωμάτια, τα οποία περικλείονται από τοίχους και συνδέονται μεταξύ τους με διαδρόμους. Η τοποθέτηση αυτών των tiles σε σωστές θέσεις ώστε να σχηματίζονται επίπεδα που ταιριάζουν στην παραπάνω περιγραφή είναι ο γενικός στόχος των συστημάτων PCG και MLPG που προσπαθούμε να υλοποιήσουμε.

\section{Υλοποίηση συστήματος PCG}

\subsection{Υποσυστήματα}
Το σύστημα PCG αποτελείται από πολλά υποσυστήματα, τα οποία θα αναλύσουμε σε αυτό το κομμάτι. Το κάθε υποσύστημα έχει σχεδιαστεί με την λογική ότι αποτελεί ένα μεμονωμένο κομμάτι λογισμικού, παίρνει συγκεκριμένες εισόδους από άλλα υποσυστήματα ή τον χρήστη και παράγει εξόδους αντίστοιχα για τα άλλα υποσυστήματα και τον χρήστη. Ονομαστικά αυτά τα υποσυστήματα είναι:

\begin{description}
\item[$\bullet$ Configuration System] Σύστημα αποθήκευσης και ανάγνωσης ρυθμίσεων.
\item[$\bullet$ Generation System] Περιέχει κλάσεις και μεθόδους για την δημιουργία ενός ή παραπάνω επιπέδων.
\item[$\bullet$ Data System] Περιέχει τις δομές δεδομένων, τις abstract κλάσεις και τα enumerations που αναπαριστούν όλες τις πληροφορίες που διαχειρίζεται το σύστημα PCG.
\item[$\bullet$ IO System] Παρέχει μεθόδους για την αποθήκευση των δημιουργημένων επιπέδων σε διάφορες μορφές όπως σε μορφή γράφουν ή σε αρχείο. Επίσης παρέχει μεθόδους για την ανάγνωση επιπέδων και μετατροπή τους σε κάποια άλλη μορφή αναπαράστασης.
\item[$\bullet$ UI System] Περιέχει την λειτουργικότητα του συστήματος αλληλεπίδρασης με τον χρήστη.
\item[$\bullet$ Evaluation System] Είναι υπεύθυνο για την αξιολόγηση ενός επιπέδου με βάση συγκεκριμένους κανόνες που ορίζονται κατά την υλοποίηση.
\end{description}

\subsection{Αλγόριθμος PCG}
Ως βασικός αλγόριθμος για το σύστημα δημιουργίας επιπέδων 2D χρησιμοποιήθηκε ένας αλγόριθμος \textit{Space Partitioning}. O αλγόριθμος παίρνει τις διαστάσεις του επιπέδου, οι οποίες όπως είπαμε είναι σταθερές για κάθε επίπεδο, και χωρίζει το δωμάτιο οριζόντια σε τυχαίο αριθμό από παράλληλα επίπεδα. Στη συνέχεια για κάθε παράλληλο επίπεδο το χωρίζει κάθετα σε τυχαία δωμάτια. Ο αριθμός των παράλληλων και των κάθετων διαχωρισμός επιλέγετε τυχαία με βάση το μέγεθος του επιπέδου.
\par
Με αυτό τον αλγόριθμο μπορούμε να έχουμε επίπεδα που ακολουθούν ένα συγκεκριμένο μοτίβο αλλά διαφέρουν στον αριθμό και το μέγεθος των δωματίων που έχει το καθένα όπως θα δούμε και στα παραδείγματα των δημιουργημένων επιπέδων.
\par
Όλη η διαδικασία δημιουργίας του επιπέδου γίνετε άμεσα χωρίς να υπάρχει κάποια εμφανή καθυστέρηση στον χρήστη. Για την δημιουργία του \textit{dataset} υλοποιήθηκε η επιλογή ο αλγόριθμος PCG να τρέξει για έναν αριθμό επαναλήψεων, προκαθορισμένο από τον χρήστη ώστε να παράγει μαζικά πολλά επίπεδα.

\subsection{Βήματα αλγορίθμου PCG}
Τα βήματα του αλγορίθμου PCG αναλυτικά είναι:

\begin{enumerate}
	\item Γέμισμα όλου του επιπέδου με ένα είδος tile. Αυτό το tile είναι του είδους \textbf{Room}.
	\item Ανάθεση των tiles που είναι στις άκρες του επιπέδου με tiles είδους \textbf{Wall}
	\item Ανάθεση των tiles που είναι στις άκρες του επιπέδου, δίπλα στα tiles με είδος \textbf{Wall} με tiles είδους \textbf{Corridor}.
	\item Υπολογισμός δωματίων.
	\item Τοποθέτηση δωματίων στο επίπεδο. Σε αυτό το βήμα ο τα tiles που δεν είναι είδους \textbf{Room} γίνονται tiles είδους \textbf{Corridor}.
	\item Τοποθέτηση tiles είδους \textbf{Wall} γύρω από τα δωμάτια.
	\item Αποθήκευση παραγομένου επιπέδου σε αρχείο.
	\item Αξιολόγηση του επιπέδου. Προαιρετικό βήμα.
\end{enumerate}


\subsection{Κανόνες μετατροπής}
Για τα βήματα \textit{2}, \textit{5} και \textit{6} όπου υλοποιείται η μετατροπή \textit{tiles} από ένα είδος σε ένα άλλο χρησιμοποιήθηκαν κανόνες μετατροπής. Οι κανόνες αυτοί παίρνουν ως είσοδο ένα tile και ανάλογα με το είδος του κανόνα το μετατρέπουν σε κάποιο άλλο είδος tile ή το αφήνουν ίδιο.
\par
Υλοποιήθηκαν δύο κατηγορίες κανόνων. H πρώτη κατηγορία περιέχει κανόνες όπως αυτοί που αναλύσαμε στο κομμάτι σχετικά με τα \textbf{Cellular Automata} που χρησιμοποιούν την \textit{γειτονιά} του tile για την μετατροπή. Η δεύτερη κατηγορία χρησιμοποιεί όρια μιας περιοχής για να εφαρμόσει μετατροπές στο είδος των tiles αυτής της περιοχής. 
\par
Για την πρώτη κατηγορία, υλοποιήθηκε η λογική της \textit{γειτονιάς} ενός \textit{tile} (cell) και ορίστηκε σε μια γενική μορφή (\textit{abstraction}) η έννοια του κανόνα. Ο κανόνας ως \textit{abstract class} μπορεί να εφαρμοστεί σε ένα \textit{tile} και ανάλογα με την υλοποίηση που έχει γίνει και την \textit{γειτονιά} του tile να γίνει μετατροπή του tile από ένα είδος σε ένα άλλο. Για τις ανάγκες αυτής της υλοποίησης χρησιμοποιήθηκε η \textbf{Moore Neighborhood} και η \textbf{Von Neumann Neighborhood} ανάλογα με τις ανάγκες κάθε κανόνα. Η γειτονιά μας σε κάθε περίπτωση είναι απόστασης \textit{X = 1}.
\par
Η ίδια γενική μορφή (\textit{abstraction}) ακολουθήθηκε και για την υλοποίηση των κανόνων της δεύτερης κατηγορίας. Τα όρια μπορεί να είναι τα όρια του επιπέδου, σε αυτή την περίπτωση ο κανόνας που θα εφαρμοστεί να μετατρέψει μόνο τα tiles περιμετρικά του επιπέδου σε ότι είδος δώσουμε ως παράμετρο όταν εφαρμόσουμε τον κανόνα.
\par
Οι κανόνες που υλοποιήθηκαν για αυτή την εφαρμογή είναι οι εξής:

\begin{description}
\item[$\bullet$ WALL FROM BOUNDS] Κανόνας μετατροπής σε \textbf{Wall} των tiles που είναι στα όρια μιας περιοχής. Χρησιμοποιείται για να γεμίσει περιμετρικά το επίπεδο με \textbf{Wall} tiles.
\item[$\bullet$ FLOOR FROM BOUNDS] Κανόνας μετατροπής σε \textbf{Corridor} των tiles που είναι στα όρια μιας περιοχής. Χρησιμοποιείται για να γεμίσει με διαδρόμους τους χώρους γύρω από τα δωμάτια και τους περιμετρικούς τοίχους.
\item[$\bullet$ WALL FOR ROOM] Κανόνας μετατροπής σε \textbf{Wall} των tiles με βάση την \textbf{Von Neumann Neighborhood}. Αυτός ο κανόνας ελέγχει όλα τα tiles της γειτονιάς και αν έστω και ένα είναι είδους\textbf{Corridor} τότε μετατρέπει το tile σε \textbf{Wall}. Χρησιμοποιείται για να κλείσει τα δωμάτια με τοίχους.
\item[$\bullet$ WALL FROM ADJACENTS] Κανόνας μετατροπής σε \textbf{Wall} των tiles με βάση την \textbf{Moore Neighborhood}. Εάν τα μισά και παραπάνω tiles της γειτονιάς είναι είδους \textbf{Wall} τότε και το tile θα μετατραπεί σε \textbf{Wall}.
\item[$\bullet$ ROOM FROM ADJACENTS] Κανόνας μετατροπής σε \textbf{Room} των tiles με βάση την \textbf{Von Neumann Neighborhood}. Εάν τα μισά και παραπάνω tiles της γειτονιάς είναι είδους \textbf{Room} τότε και το tile θα μετατραπεί σε \textbf{Room}.
\end{description}

\par
Οι δύο τελευταίοι κανόνες αν και υλοποιήθηκαν για τις αρχικές ανάγκες της εφαρμογής τελικά αντικαταστάθηκαν από τους άλλους κανόνες και δεν χρησιμοποιούνται στην τελική της έκδοση. O κώδικας παρέμεινε στην εφαρμογή και περιγράφετε και εδώ για θεωρητικούς λόγους.

\section{Δημιουργία Συνόλου Δεδομένων (\textit{Dataset})}
Με τον παραπάνω αλγόριθμο περιγράψαμε πως δημιουργείται ένα επίπεδο στο \textit{Unity Game Engine}. Αυτό το επίπεδο πρέπει να αναπαρασταθεί και να αποθηκευτεί σε μια μορφή που να μπορεί να διαβάσει και να επεξεργαστεί ο αλγόριθμος του \textit{MLPG}. Αυτή η μετατροπή γίνετε από το \textit{IO System} που αναπτύχθηκε επίσης στο \textit{Unity Game Engine} με σκοπό την αποθήκευση και ανάγνωση επιπέδων με μια συγκεκριμένη αναπαράσταση.
\par
Αρχικά έπρεπε να γίνει μια καταγραφή των δεδομένων που απαιτούνται από το σύστημα \textit{MLPG} για την εκπαίδευση ώστε να αποθηκεύεται η ελάχιστη δυνατή πληροφορία κατά την δημιουργία του \textit{dataset}. Αυτό μπορούμε να το δούμε ως μια συμπιεσμένη αναπαράσταση του επιπέδου που περιέχει μόνο τα απαραίτητα για την εκπαίδευση δεδομένα.
\par
Το \textit{IO System} επίσης θα πρέπει να μπορεί να δημιουργήσει το αρχικό επίπεδο από την αυτή τη συμπιεσμένη αναπαράσταση χωρίς να χάσει κάποιο κομμάτι του επιπέδου ή να αλλοιωθεί η μορφή του με τον οποιοδήποτε τρόπο. Επιλέχθηκε η αναπαράσταση του επιπέδου σε \textit{csv} αρχείο με τα όπου η κάθε γραμμή στο αρχείο αντιστοιχεί σε ένα \textit{tile} του επιπέδου με τα εξής πεδία:

\begin{description}
\item[$\bullet$ Tile X] Αντιπροσωπεύει ακέραιο θετικό αριθμό ή μηδέν και δείχνει την συντεταγμένη \textit{x} του \textit{tile}
\item[$\bullet$ Tile Y] Αντιπροσωπεύει ακέραιο θετικό αριθμό ή μηδέν και δείχνει την συντεταγμένη \textit{y} του \textit{tile}
\item[$\bullet$ Tile Type] Μπορεί να πάρει μία από τις τιμές \textit{[0, 1, 2]} όπου ο κάθε αριθμός αντιστοιχεί σε ένα από τα είδη των \textit{tiles}\textit{[0: CORRIDOR, 1: WALL, 2: ROOM]}.
\end{description}

Αυτή η απλή αναπαράσταση ήταν αρκετή για να αποτυπώσουμε όλη την πληροφορία που χρειάζεται να γνωρίζει το \textit{MLPG} για να εκπαιδεύσει τα μοντέλα του. Κάθε επίπεδο αποθηκεύεται σε ξεχωριστό αρχείο και το \textit{dataset} αποτελεί έναν φάκελο με όλα τα αρχεία-επίπεδα που περιέχει.
\par
Αντίστοιχες μέθοδοι ανάγνωσης και εγγραφής δημιουργήθηκαν και στην υλοποίηση του \textit{MLPG} όπως θα αναλυθούν στο αντίστοιχο κεφάλαιο.













